; FIXME: license, for now defaults to Copyright (C) Miaou 2025

.program libcicada
.side_set 1

;.lang_opt python sideset_init = 1  ; we could generate the python, but this requires an additional target in the CMakeLists and calling pioasm manually

; We want:
; - configurable durations (configurable freqs)
; - number of repetitions
; - silences

; x and y are 32 bits

; Let's start with 200kHz, so that a bit is 5Âµs
; 19/38 bits (19 0, 19 1) produces 5263 Hz
; 20 bits -> 5.000 kHz
; 21      -> 4.761
; 22      -> 4.545
; 23      -> 4.348
; ... 31 needs 5 bits

; To have good timing, knowing that the loop consumes x+1 cycles,
;  we add preamble of 3 cycles, and postamble of 5 cycles, leaving time to cover all cases
; side = 1     -------------------------
; side = 0 ----                         --------------------
;              === preamble
;                 <==x+1 cycles===>
;                        postamble =====

; With clk the frequency of the PIO:
;  freq = clk/(2*(x+9)) in Hz,
;  duration = (y+1)*2*(x+9)/clk in seconds.
; To produce a sound of freq and duration:
;  x = clk/(2*f) - 9
;  y = duration*freq - 1
; To silence:
;  x = 0
;  duration = (16*(y+1)+3)/clk hence y = (duration*clk-3)/16 - 1
decode:
    out x, 16       side 0 ; Half wave length, leave side=0 to not activate the buzzer
    jmp !x, silence side 0
    out y, 16       side 1 ; Number of repetitions, set side=1 because we won't block here
    mov isr, x      side 1 ; Use ISR as third scratch register
    jmp up          side 1 ; pin=1 for 3

preup: ; come from down (repetitions)
    nop             side 0 [2]  ; pin=0 for 3 +x+1 +5 (end of postamble)
    nop             side 1 [2]  ; pin=1 for 3 (preamble)
up:
    jmp x--, up     side 1      ; pin=1 for 3 +x+1
    mov x, isr      side 1      ; pin=1 for 3 +x+1 +1
    nop             side 1 [3]  ; pin=1 for 3 +x+1 +5

    nop             side 0 [2]  ; pin=0 for 3 (preamble)
down:
    jmp x--, down   side 0      ; pin=0 for 3 +x+1

    mov x, isr      side 0      ; pin=0 for 3 +x+1 +1
    jmp y--, preup  side 0      ; pin=0 for 3 +x+1 +2
    jmp decode      side 0      ; pin=0 for 3 +x+1 +3 will go to +5

silence:
    out y, 16       side 0 ; Number of repetitions
siloop:
    jmp y--, siloop side 0 [15] ; 16*(y+1) + 3
    jmp decode      side 0


% c-sdk {
#include "hardware/clocks.h"
static inline void libcicada_program_init(PIO pio, uint sm, uint offset, uint pin) {
    pio_sm_config c = libcicada_program_get_default_config(offset);

    // side should output on pin
    sm_config_set_sideset_pin_base(&c, pin);
    // Set this pin's GPIO function (connect PIO to the pad)
    pio_gpio_init(pio, pin);
    // Set the pin direction to output at the PIO
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true);

    // For OUT: shift right, autopull and use all 32 bits
    sm_config_set_out_shift(&c, true, true, 32);

    //// Lengthen the TX FIFO (4 to 8), but no RX anymore
    //sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);

    // Set the frequency of the SM
    float div = clock_get_hz(clk_sys) / 200000;  // TODO put this clock in a define
    sm_config_set_clkdiv(&c, div);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
}
%}
