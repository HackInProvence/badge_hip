; FIXME: license, for now defaults to Copyright (C) Miaou 2025

; The rate at which the machine runs
.define PUBLIC CLOCK 200000

.program libcicada
.side_set 1

;.lang_opt python sideset_init = 1  ; we could generate the python, but this requires an additional target in the CMakeLists and calling pioasm manually

; We want:
; - configurable durations (configurable freqs)
; - number of repetitions
; - silences

; x and y are 32 bits

; Let's start with 200kHz, so that a bit is 5Âµs
; 19/38 bits (19 0, 19 1) produces 5263 Hz
; 20 bits -> 5.000 kHz
; 21      -> 4.761
; 22      -> 4.545
; 23      -> 4.348

; With clk the frequency of the PIO:
;  freq = clk/(2*(x+9)) in Hz,
;  duration = (y+1)*2*(x+9)/clk in seconds.
; To produce a sound of freq and duration:
;  x = clk/(2*f) - 9
;  y = duration*freq - 1
; To stay silent:
;  x = 0
;  duration ~ 512*(y+1)/clk ~= (y+1)*2.56ms (< 41ms)
;  hence y = (duration*clk)/512 - 1 (must be < 16)

; With 4 bits for x: we can go from clk/(2*(15+9))=4.2kHz to clk/(2*(1+9))=10kHz
; With 4 bits for y and x=11 (5kHz): we can go from 0.2ms to 3.2ms
; We can stack 4 (x,y) per FIFO word and 4 others in the queue.

; To have good timing, knowing that the loop consumes x+1 cycles,
;  we add preamble of 3 cycles, and postamble of 5 cycles, leaving time to cover all cases
; side = 1     -------------------------
; side = 0 ----                         --------------------
;              === preamble
;                 <==x+1 cycles===>
;                        postamble =====
; first preamble (first 1): decode y, save x, start up
; 1 -> 0: postamble resets x, preamble unused
; 0 -> 1: postamble resets x and jumps, preamble unused
; last 0: postamble resets x + decode next x
; silences are flat 0 and don't require precise timings
decode:
    out x, 4        side 0 ; Half wave length, leave side=0 to not activate the buzzer
    jmp !x, silence side 0
    out y, 4        side 1 ; Number of repetitions, set side=1 because we won't block here
    mov isr, x      side 1 ; Use ISR as third scratch register
    jmp up          side 1 ; pin=1 for 3

preup: ; come from down (repetitions)
    nop             side 0 [2]  ; pin=0 for 3 +x+1 +5 (end of postamble)
    nop             side 1 [2]  ; pin=1 for 3 (preamble)
up:
    jmp x--, up     side 1      ; pin=1 for 3 +x+1
    mov x, isr      side 1      ; pin=1 for 3 +x+1 +1
    nop             side 1 [3]  ; pin=1 for 3 +x+1 +5 (postamble)

    nop             side 0 [2]  ; pin=0 for 3 (preamble)
down:
    jmp x--, down   side 0      ; pin=0 for 3 +x+1

    mov x, isr      side 0      ; pin=0 for 3 +x+1 +1
    jmp y--, preup  side 0      ; pin=0 for 3 +x+1 +2
    jmp decode      side 0      ; pin=0 for 3 +x+1 +3 will go to +5

silence:
    out y, 4        side 0      ; Number of repetitions
    mov isr, y      side 0      ; Keep y to be able to repeat this subloop
    set x, 31       side 0      ; Also loop 32 times to lengthen silences to 2.56ms per y
silx:
    mov y, isr      side 0
sily:
    jmp y--, sily   side 0 [15] ; ~ 16*(y+1)*32 = 512*(y+1)
    jmp x--, silx   side 0
    jmp decode      side 0


% c-sdk {
#include "hardware/clocks.h"
static inline void libcicada_program_init(PIO pio, uint sm, uint offset, uint pin) {
    pio_sm_config c = libcicada_program_get_default_config(offset);

    // side should output on pin
    sm_config_set_sideset_pin_base(&c, pin);
    // Set this pin's GPIO function (connect PIO to the pad)
    pio_gpio_init(pio, pin);
    // Set the pin direction to output at the PIO
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true);

    // For OUT: shift right, autopull and use all 32 bits
    sm_config_set_out_shift(&c, true, true, 32);

    //// Lengthen the TX FIFO (4 to 8), but no RX anymore
    //sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);

    // Set the frequency of the SM
    float div = clock_get_hz(clk_sys) / CLOCK;
    sm_config_set_clkdiv(&c, div);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
}
%}
